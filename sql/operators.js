const operators = [
  // === DATA ACCESS ===
  { name: "Clustered Index Scan", category: "Data Access", icon: "icon-clustered-index-scan", summary: "Scans the entire clustered index (basically a full table scan).", detail: "Reads all rows from the clustered index. When a Predicate is present, only matching rows are returned. If the Ordered property is True, rows come back in index order. Can be expensive on large tables — often a sign you need a better index or a WHERE clause.", perf: "Full scans on large tables are expensive. Consider adding a WHERE clause or appropriate index to enable a seek instead.", types: ["Logical", "Physical"], msDoc: "The **Clustered Index Scan** operator scans the clustered index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. When an optional **Predicate** is present, only those rows that satisfy the predicate are returned. If the **Ordered** property in the **Properties** pane or XML showplan is **True**, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them. If the **Ordered** property is **False**, the Database Engine scans the index in the optimal way, without necessarily sorting the output.\n\n**Clustered Index Scan** is a logical and physical operator." },
  { name: "Clustered Index Seek", category: "Data Access", icon: "icon-clustered-index-seek", summary: "Uses the clustered index to directly find specific rows.", detail: "Uses the B-tree structure of the clustered index to jump directly to the rows matching the SeekPredicate. Much more efficient than a scan for selective queries. May include an additional Predicate (residual filter) evaluated after the seek.", perf: "This is what you want to see. If you're getting scans instead, check your WHERE clause and indexes.", types: ["Logical", "Physical"], msDoc: "The **Clustered Index Seek** operator uses the seeking ability of indexes to retrieve rows from a clustered index. The **Object** property, listed in the **Properties** pane of the graphical and XML showplans, contains the name of the clustered index being used. The **SeekPredicate** contains the predicate for the seek. The Database Engine uses the index to process only those rows that satisfy the **SeekPredicate**. It can also include a **Predicate** property where the Database Engine evaluates against all rows that satisfy the **SeekPredicate**, but this is optional and doesn't use indexes to complete this process.\n\nIf the **Ordered** property in the **Properties** pane or XML showplan is **True**, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them. If the **Ordered** property is **False**, the Database Engine searches the index in the optimal way, without necessarily sorting the output. Requiring the output to retain its ordering can be less efficient than producing nonsorted output.\n\n**Clustered Index Seek** is a logical and physical operator." },
  { name: "Index Scan", category: "Data Access", icon: "icon-nonclustered-index-scan", summary: "Scans an entire nonclustered index.", detail: "Reads all rows from a nonclustered index. If a WHERE predicate is present, only matching rows are returned. Can be more efficient than a clustered index scan if the nonclustered index is narrower (fewer columns).", perf: "Still a full scan, just on a smaller structure. Consider if an index seek would be possible with different predicates.", types: ["Logical", "Physical"], msDoc: "The **Index Scan** operator retrieves all rows from the nonclustered index specified in the **Properties** pane. If an optional *where* predicate appears in the **Properties** pane, only those rows that satisfy the predicate are returned.\n\n**Index Scan** is a logical and physical operator." },
  { name: "Index Seek", category: "Data Access", icon: "icon-nonclustered-index-seek", summary: "Directly finds rows using a nonclustered index.", detail: "Uses the B-tree of a nonclustered index to find matching rows via the seek predicate. May include a residual WHERE predicate. If ORDERED is specified, rows come back in index order. This is generally the most efficient way to retrieve specific rows.", types: ["Logical", "Physical"], msDoc: "The **Index Seek** operator uses the seeking ability of indexes to retrieve rows from a nonclustered index. The **Properties** pane contains the name of the nonclustered index being used. It also contains the *seek* predicate. The Database Engine uses the index to process only those rows that satisfy the *seek* predicate. It optionally might include a *where* predicate, which the Database Engine evaluates against all rows that satisfy the *seek* predicate (it doesn't use the indexes to do this). If the **Properties** pane contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them. If the ORDERED clause isn't present, the Database Engine searches the index in the optimal way (which doesn't guarantee that the output is sorted). Allowing the output to retain its ordering might be less efficient than producing nonsorted output.\n\n**Index Seek** is a logical and physical operator." },
  { name: "Key Lookup", category: "Data Access", icon: "icon-key-lookup", summary: "Goes back to the clustered index to get columns not in the nonclustered index.", detail: "After an Index Seek finds rows via a nonclustered index, Key Lookup fetches the remaining columns from the clustered index using the clustering key. Always paired with a Nested Loops operator. WITH PREFETCH means it uses read-ahead for better I/O.", perf: "Key Lookups can be expensive with many rows. Add missing columns to the nonclustered index as INCLUDE columns (covering index) to eliminate them.", types: ["Physical"], msDoc: "The **Key Lookup** operator is a bookmark lookup on a table with a clustered index. The **Properties** pane contains the name of the clustered index and the clustering key used to look up the row in the clustered index. **Key Lookup** is always accompanied by a **Nested Loops** operator. If the WITH PREFETCH clause appears in the **Properties** pane, the query processor has determined that it's optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.\n\nThe use of a **Key Lookup** operator in a query plan indicates that the query might benefit from performance tuning. For example, query performance might be improved by adding a covering index." },
  { name: "RID Lookup", category: "Data Access", icon: "icon-rid-lookup", summary: "Looks up a row in a heap using the Row ID.", detail: "Similar to Key Lookup but for heap tables (no clustered index). Uses the physical Row ID (file:page:slot) to fetch the full row after a nonclustered index seek. Always paired with Nested Loops.", perf: "Consider adding a clustered index to the table, or making the nonclustered index a covering index.", types: ["Physical"], msDoc: "**RID Lookup** is a bookmark lookup on a heap using a supplied row identifier (RID). The **Properties** pane contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up. **RID Lookup** is always accompanied by a NESTED LOOP JOIN.\n\n**RID Lookup** is a physical operator." },
  { name: "Table Scan", category: "Data Access", icon: "icon-table-scan", summary: "Reads every row in a heap table.", detail: "Scans the entire heap (a table without a clustered index). This is the least efficient data access method for large tables since every row must be examined.", perf: "On large tables, this is a red flag. Add a clustered index, or at minimum a nonclustered index to enable seeks.", types: ["Logical", "Physical"], msDoc: "The **Table Scan** operator retrieves all rows from the table specified in the **Object** property, listed in the **Properties** pane. If a *where* predicate appears in the **Properties** pane, only those rows that satisfy the predicate are returned.\n\n**Table Scan** is a logical and physical operator." },
  { name: "Constant Scan", category: "Data Access", icon: "icon-constant-scan", summary: "Introduces constant values into a query.", detail: "Produces one or more rows of constant values. Often used with Compute Scalar to build rows. Common in queries with hardcoded values, UNION with constants, or VALUES clauses.", types: ["Logical", "Physical"], msDoc: "The **Constant Scan** operator introduces one or more constant rows into a query. A **Compute Scalar** operator is often used after a **Constant Scan** to add columns to a row produced by the **Constant Scan** operator. **Constant Scan** can generate one or more rows with zero or more columns." },
  { name: "Columnstore Index Scan", category: "Data Access", icon: "icon-columnstore-index-scan", summary: "Scans a columnstore index (optimized for analytics).", detail: "Scans a clustered or nonclustered columnstore index. Uses batch mode processing for high throughput on analytical queries. Can eliminate row groups via segment elimination when predicates match column min/max metadata.", types: ["Physical"], msDoc: "The **Columnstore Index Scan** operator represents a scan of the columnstore index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. The scan occurs via the **Clustered Index Scan** for a clustered columnstore index, and via the **Index Scan** operator for a nonclustered columnstore index. The index type (*Clustered*, *NonClustered*, or *ViewNonClustered*) is specified in the **IndexKind** property in the XML showplan. When an optional **Predicate** is present, only those rows that satisfy the predicate are returned. The **SeekPredicate** property is only available for a partitioned columnstore index, and only equality or inequality conditions. If the partitioned column is in query predicate, partition elimination can reduce the number of rowgroups to scan.\n\n**Columnstore Index Scan** is a physical operator." },
  { name: "Remote Index Scan", category: "Data Access", icon: "icon-remote-index-scan", summary: "Scans an index on a remote (linked) server.", detail: "Scans a nonclustered index on a remote server via a linked server connection. Performance depends on network latency and remote server load.", types: ["Logical", "Physical"], msDoc: "**Remote Index Scan** scans a nonclustered index on a remote server via a linked server connection. Performance depends on network latency and remote server load." },
  { name: "Remote Index Seek", category: "Data Access", icon: "icon-remote-index-seek", summary: "Seeks into an index on a remote (linked) server.", detail: "Uses the seeking ability of an index on a remote linked server. More efficient than Remote Index Scan when seeking specific rows.", types: ["Logical", "Physical"], msDoc: "**Remote Index Seek** uses the seeking ability of an index on a remote linked server. More efficient than Remote Index Scan when seeking specific rows." },
  { name: "Remote Query", category: "Data Access", icon: "icon-remote-query", summary: "Sends a query to a remote (linked) server.", detail: "Submits a query to a remote data source via OLE DB. The entire query is sent remotely, and results are streamed back. Used in distributed queries with linked servers.", types: ["Logical", "Physical"], msDoc: "**Remote Query** submits a query to a remote data source via OLE DB. The entire query is sent remotely, and results are streamed back. Used in distributed queries with linked servers." },
  { name: "Remote Scan", category: "Data Access", icon: "icon-remote-scan", summary: "Scans a remote table on a linked server.", detail: "Scans a table on a remote server. Results are streamed back to the local server for further processing.", types: ["Logical", "Physical"], msDoc: "**Remote Scan** scans a table on a remote server. Results are streamed back to the local server for further processing." },
  { name: "Log Row Scan", category: "Data Access", icon: "icon-log-row-scan", summary: "Scans the transaction log.", detail: "Reads rows from the SQL Server transaction log. Used internally for certain operations that need log data.", types: ["Logical", "Physical"], msDoc: "**Log Row Scan** reads rows from the SQL Server transaction log. Used internally for certain operations that need log data." },
  { name: "Deleted Scan", category: "Data Access", icon: "icon-deleted-scan", summary: "Scans the 'deleted' table inside a trigger.", detail: "In trigger context, scans the virtual 'deleted' table which contains the before-image of rows affected by DELETE or UPDATE statements.", types: ["Logical", "Physical"], msDoc: "**Deleted Scan** in trigger context, scans the virtual 'deleted' table which contains the before-image of rows affected by DELETE or UPDATE statements." },
  { name: "Inserted Scan", category: "Data Access", icon: "icon-inserted-scan", summary: "Scans the 'inserted' table inside a trigger.", detail: "In trigger context, scans the virtual 'inserted' table which contains the after-image of rows affected by INSERT or UPDATE statements.", types: ["Logical", "Physical"], msDoc: "**Inserted Scan** in trigger context, scans the virtual 'inserted' table which contains the after-image of rows affected by INSERT or UPDATE statements." },
  { name: "Parameter Table Scan", category: "Data Access", icon: "icon-parameter-table-scan", summary: "Reads the internal rowset from INSERT...EXEC.", detail: "Reads the result set produced by a stored procedure or dynamic SQL batch during an INSERT...EXEC statement.", types: ["Logical", "Physical"], msDoc: "**Parameter Table Scan** reads the result set produced by a stored procedure or dynamic SQL batch during an INSERT...EXEC statement." },

  // === JOINS ===
  { name: "Nested Loops", category: "Joins", icon: "icon-nested-loops", summary: "For each outer row, searches the inner input. Best for small outer sets with indexed inner.", detail: "For each row in the outer (top) input, performs a search on the inner (bottom) input, typically using an index. Very efficient when the outer input is small and the inner input has a good index. OPTIMIZED=True means it uses Batch Sort for better I/O locality.", perf: "Great with small outer inputs and indexed inner inputs. If the outer set is large, a Hash Match or Merge Join may be better.", types: ["Physical"], msDoc: "The **Nested Loops** operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations. Nested loop joins perform a search on the inner table for each row of the outer table, typically using an index. The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input. Any rows that satisfy the (optional) predicate in the **Properties** pane are returned as applicable, based on the logical operation being performed. When the OPTIMIZED attribute is set to True, it means that an Optimized Nested Loops (or Batch Sort) is used.\n\n**Nested Loops** is a physical operator." },
  { name: "Hash Match", category: "Joins", icon: "icon-hash-match", summary: "Builds a hash table from one input, probes it with the other. Good for large unsorted inputs.", detail: "Builds a hash table from the build (top) input, then probes it with each row from the probe (bottom) input. Also used for aggregation (GROUP BY) and distinct operations. If the hash table exceeds memory, it spills to tempdb. A residual predicate may filter matches further.", perf: "Hash joins need memory for the hash table. Very large builds can spill to tempdb. Consider indexes that enable Merge Join or Nested Loops instead.", types: ["Physical"], msDoc: "The **Hash Match** operator builds a hash table by computing a hash value for each row from its build input. A *hash* predicate, with a list of columns used to create a hash value, appears in the **Properties** pane. Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches. If a residual predicate is present (identified by RESIDUAL:() in the **Properties** pane), that predicate must also be satisfied for rows to be considered a match.\n\nBehavior depends on the logical operation being performed:\n- For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table. Output matches (or nonmatches) as dictated by the join type. If multiple joins use the same join column, these operations are grouped into a hash team.\n- For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions). When the hash table is built, scan the table and output all entries.\n- For the union operator, use the first input to build the hash table (removing duplicates). Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.\n\n**Hash Match** is a physical operator." },
  { name: "Merge Join", category: "Joins", icon: "icon-merge-join", summary: "Merges two sorted inputs. Very efficient when both inputs are already sorted.", detail: "Requires both inputs to be sorted on the join columns. Walks through both sorted streams simultaneously. Supports inner, outer, semi, and anti semi joins plus UNION. Many-to-many merges require a worktable. Extremely efficient when data is pre-sorted (e.g., from indexes).", perf: "Merge Join is very efficient but requires sorted inputs. If you see Sort operators feeding into it, the overall cost may be high.", types: ["Physical"], msDoc: "The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations. In the **Properties** pane, the **Merge Join** operator contains a *merge* predicate if the operation is performing a one-to-many join, or a *many-to-many merge* predicate if the operation is performing a many-to-many join. The **Properties** pane also includes a comma-separated list of columns used to perform the operation. The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan. Merge join is particularly effective if explicit sorting isn't required, for example, if there's a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with rollup.\n\n**Merge Join** is a physical operator." },
  { name: "Adaptive Join", category: "Joins", icon: "icon-adaptive-join", summary: "Dynamically picks between Hash Join and Nested Loops at runtime.", detail: "Defers the choice between Hash Join and Nested Loops until after scanning the first input. If the actual row count is below the adaptive threshold, switches to Nested Loops; otherwise uses Hash Join. Introduced in SQL Server 2017 as part of Intelligent Query Processing.", types: ["Physical"], msDoc: "The **Adaptive Join** operator enables the choice of a hash join or nested loops join method to be deferred until after the first input has been scanned.\n\n**Adaptive Join** is a physical operator." },
  { name: "Inner Join", category: "Joins", icon: "icon-join", summary: "Returns rows where both inputs match the join predicate.", detail: "Logical operation that returns only rows satisfying the join condition from both inputs. Implemented physically by Nested Loops, Hash Match, or Merge Join.", types: ["Logical"], msDoc: "**Inner Join** returns rows where both inputs match the join predicate. Logical operation that returns only rows satisfying the join condition from both inputs. Implemented physically by Nested Loops, Hash Match, or Merge Join." },
  { name: "Left Outer Join", category: "Joins", icon: "icon-join", summary: "Returns all rows from the left input, with NULLs for non-matching right rows.", detail: "Returns all rows from the first (top) input. For rows with matches in the second input, includes the matched columns. For non-matching rows, fills second input columns with NULLs.", types: ["Logical"], msDoc: "**Left Outer Join** returns all rows from the left input, with NULLs for non-matching right rows. Returns all rows from the first (top) input. For rows with matches in the second input, includes the matched columns. For non-matching rows, fills second input columns with NULLs." },
  { name: "Right Outer Join", category: "Joins", icon: "icon-join", summary: "Returns all rows from the right input, with NULLs for non-matching left rows.", detail: "Returns all rows from the second (bottom) input. For rows with matches in the first input, includes the matched columns. Non-matching rows get NULLs for the first input's columns.", types: ["Logical"], msDoc: "**Right Outer Join** returns all rows from the right input, with NULLs for non-matching left rows. Returns all rows from the second (bottom) input. For rows with matches in the first input, includes the matched columns. Non-matching rows get NULLs for the first input's columns." },
  { name: "Full Outer Join", category: "Joins", icon: "icon-join", summary: "Returns all rows from both inputs, NULLs where there's no match.", detail: "Returns matched rows from both inputs, plus unmatched rows from each side with NULLs for the missing side's columns.", types: ["Logical"], msDoc: "**Full Outer Join** returns all rows from both inputs, NULLs where there's no match. Returns matched rows from both inputs, plus unmatched rows from each side with NULLs for the missing side's columns." },
  { name: "Cross Join", category: "Joins", icon: "icon-join", summary: "Cartesian product — every row from left joined with every row from right.", detail: "Produces the Cartesian product of both inputs. Every row from the first input is paired with every row from the second input. Result set size = left rows × right rows.", perf: "Cross joins can produce enormous result sets. Make sure this is intentional.", types: ["Logical"], msDoc: "**Cross Join** produces the Cartesian product — every row from left joined with every row from right. Produces the Cartesian product of both inputs. Every row from the first input is paired with every row from the second input. Result set size = left rows × right rows." },
  { name: "Left Semi Join", category: "Joins", icon: "icon-join", summary: "Returns left rows that have at least one match on the right (like EXISTS).", detail: "Returns rows from the first input where at least one matching row exists in the second input. Only returns columns from the first input. Commonly seen with EXISTS or IN subqueries.", types: ["Logical"], msDoc: "**Left Semi Join** returns left rows that have at least one match on the right (like EXISTS). Returns rows from the first input where at least one matching row exists in the second input. Only returns columns from the first input. Commonly seen with EXISTS or IN subqueries." },
  { name: "Left Anti Semi Join", category: "Joins", icon: "icon-join", summary: "Returns left rows that have NO match on the right (like NOT EXISTS).", detail: "Returns rows from the first input where no matching row exists in the second input. Common with NOT EXISTS or NOT IN subqueries.", types: ["Logical"], msDoc: "**Left Anti Semi Join** returns left rows that have NO match on the right (like NOT EXISTS). Returns rows from the first input where no matching row exists in the second input. Common with NOT EXISTS or NOT IN subqueries." },
  { name: "Right Semi Join", category: "Joins", icon: "icon-join", summary: "Returns right rows that have at least one match on the left.", detail: "Returns rows from the second input where at least one matching row exists in the first input.", types: ["Logical"], msDoc: "**Right Semi Join** returns right rows that have at least one match on the left. Returns rows from the second input where at least one matching row exists in the first input." },
  { name: "Right Anti Semi Join", category: "Joins", icon: "icon-join", summary: "Returns right rows that have NO match on the left.", detail: "Returns rows from the second input where no matching row exists in the first input.", types: ["Logical"], msDoc: "**Right Anti Semi Join** returns right rows that have NO match on the left. Returns rows from the second input where no matching row exists in the first input." },

  // === SORT & GROUPING ===
  { name: "Sort", category: "Sort & Grouping", icon: "icon-sort", summary: "Sorts input rows by specified columns.", detail: "Sorts all input rows by the ORDER BY columns. Consumes all input before producing any output (blocking operator). If the data set exceeds the memory grant, it spills to tempdb. DISTINCT flag removes duplicates during the sort.", perf: "Sorts are expensive (blocking + memory). If you see sorts feeding joins, consider indexes that provide pre-sorted data.", types: ["Logical", "Physical"], msDoc: "The **Sort** operator sorts all incoming rows. The **Properties** pane contains either a *distinct order by* predicate if duplicates are removed by this operation, or an *order by* predicate with a comma-separated list of the columns being sorted. The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.\n\n**Sort** is a logical and physical operator." },
  { name: "Distinct Sort", category: "Sort & Grouping", icon: "icon-sort", summary: "Sorts input and removes duplicates in one pass.", detail: "Scans input, sorts by specified columns, and removes duplicate rows. Combines the work of Sort + Distinct into a single operator.", types: ["Logical"], msDoc: "**Distinct Sort** sorts input and removes duplicates in one pass. Scans input, sorts by specified columns, and removes duplicate rows. Combines the work of Sort + Distinct into a single operator." },
  { name: "Stream Aggregate", category: "Sort & Grouping", icon: "icon-stream-aggregate", summary: "Computes aggregates (SUM, COUNT, etc.) on pre-sorted groups.", detail: "Requires input sorted by the GROUP BY columns. Processes rows sequentially, computing aggregates as each group boundary is encountered. Very efficient since it's non-blocking and doesn't need extra memory.", types: ["Logical", "Physical"], msDoc: "The **Stream Aggregate** operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query. The output of this operator can be referenced by later operators in the query, returned to the client, or both. The **Stream Aggregate** operator requires input ordered by the columns within its groups. The optimizer uses a **Sort** operator before this operator if the data isn't already sorted due to a prior **Sort** operator or due to an ordered index seek or scan.\n\n**Stream Aggregate** is a physical operator." },
  { name: "Aggregate", category: "Sort & Grouping", icon: "icon-aggregate", summary: "Calculates MIN, MAX, SUM, COUNT, or AVG.", detail: "Computes aggregate expressions. Can be implemented physically by Stream Aggregate or Hash Match. Appears as both a logical and physical operator.", types: ["Logical", "Physical"], msDoc: "**Aggregate** calculates MIN, MAX, SUM, COUNT, or AVG. Computes aggregate expressions. Can be implemented physically by Stream Aggregate or Hash Match. Appears as both a logical and physical operator." },
  { name: "Distinct", category: "Sort & Grouping", icon: "icon-sort", summary: "Removes duplicate rows or values.", detail: "Removes duplicate rows from its input. Can be implemented by Sort (Distinct Sort), Hash Match (Hash Aggregate), or Stream Aggregate.", types: ["Logical"], msDoc: "**Distinct** removes duplicate rows or values. Removes duplicate rows from its input. Can be implemented by Sort (Distinct Sort), Hash Match (Hash Aggregate), or Stream Aggregate." },
  { name: "Flow Distinct", category: "Sort & Grouping", icon: "icon-sort", summary: "Removes duplicates row-by-row as they arrive (streaming).", detail: "Unlike Distinct (which consumes all input first), Flow Distinct returns each unique row as soon as it's encountered. Duplicates are discarded on sight.", types: ["Logical"], msDoc: "**Flow Distinct** removes duplicates row-by-row as they arrive (streaming). Unlike Distinct (which consumes all input first), Flow Distinct returns each unique row as soon as it's encountered. Duplicates are discarded on sight." },
  { name: "Segment", category: "Sort & Grouping", icon: "icon-segment", summary: "Detects group boundaries in sorted input for window functions.", detail: "Tests each row to determine if it's in the current group or a new one. Used with window functions (OVER clause) to partition rows into segments for aggregate computation.", types: ["Logical", "Physical"], msDoc: "**Segment** detects group boundaries in sorted input for window functions. Tests each row to determine if it's in the current group or a new one. Used with window functions (OVER clause) to partition rows into segments for aggregate computation." },
  { name: "Sequence Project", category: "Sort & Grouping", icon: "icon-sequence-project", summary: "Computes window functions like ROW_NUMBER, RANK, etc.", detail: "Adds window function results (ROW_NUMBER, RANK, DENSE_RANK, NTILE, LAG, LEAD, etc.) to each row. Works with Segment to handle PARTITION BY and with Sort for ORDER BY within the window.", types: ["Logical", "Physical"], msDoc: "**Sequence Project** computes window functions like ROW_NUMBER, RANK, etc. Adds window function results (ROW_NUMBER, RANK, DENSE_RANK, NTILE, LAG, LEAD, etc.) to each row. Works with Segment to handle PARTITION BY and with Sort for ORDER BY within the window." },
  { name: "Top", category: "Sort & Grouping", icon: "icon-top", summary: "Returns only the first N rows (TOP clause).", detail: "Scans input and returns only the first N rows, then stops. Also handles TOP WITH TIES. Can dramatically reduce work for downstream operators since it stops early.", types: ["Logical", "Physical"], msDoc: "**Top** returns only the first N rows (TOP clause). Scans input and returns only the first N rows, then stops. Also handles TOP WITH TIES. Can dramatically reduce work for downstream operators since it stops early." },
  { name: "Window Spool", category: "Sort & Grouping", icon: "icon-window-spool", summary: "Buffers rows for window function frame calculations.", detail: "Expands each input row into the set of rows that fall within the window frame (ROWS/RANGE BETWEEN). Used for aggregate window functions that need access to a sliding frame of rows.", types: ["Physical"], msDoc: "**Window Spool** buffers rows for window function frame calculations. Expands each input row into the set of rows that fall within the window frame (ROWS/RANGE BETWEEN). Used for aggregate window functions that need access to a sliding frame of rows." },

  // === MODIFY ===
  { name: "Insert", category: "Modify", icon: "icon-insert", summary: "Inserts rows into a table.", detail: "Logical insert operation. The physical implementation is Table Insert, Clustered Index Insert, or Index Insert depending on the target structure.", types: ["Logical"], msDoc: "**Insert** inserts rows into a table. Logical insert operation. The physical implementation is Table Insert, Clustered Index Insert, or Index Insert depending on the target structure." },
  { name: "Delete", category: "Modify", icon: "icon-delete", summary: "Deletes rows from a table.", detail: "Deletes rows that satisfy the optional predicate. Physical implementation depends on the target index type.", types: ["Logical"], msDoc: "**Delete** deletes rows from a table. Deletes rows that satisfy the optional predicate. Physical implementation depends on the target index type." },
  { name: "Update", category: "Modify", icon: "icon-clustered-index-update", summary: "Updates rows in a table.", detail: "Modifies existing rows. SetPredicate defines the new column values. Physical implementation depends on index type.", types: ["Logical"], msDoc: "**Update** updates rows in a table. Modifies existing rows. SetPredicate defines the new column values. Physical implementation depends on index type." },
  { name: "Clustered Index Insert", category: "Modify", icon: "icon-clustered-index-insert", summary: "Inserts rows into a clustered index.", detail: "Physical operator that inserts rows into the specified clustered index. Changes may also cascade to nonclustered indexes on the same table.", types: ["Physical"], msDoc: "**Clustered Index Insert** inserts rows into a clustered index. Physical operator that inserts rows into the specified clustered index. Changes may also cascade to nonclustered indexes on the same table." },
  { name: "Clustered Index Update", category: "Modify", icon: "icon-clustered-index-update", summary: "Updates rows in a clustered index.", detail: "Physical operator that updates rows in the specified clustered index. May cascade changes to nonclustered indexes.", types: ["Logical", "Physical"], msDoc: "**Clustered Index Update** updates rows in a clustered index. Physical operator that updates rows in the specified clustered index. May cascade changes to nonclustered indexes." },
  { name: "Clustered Index Delete", category: "Modify", icon: "icon-clustered-index-delete", summary: "Deletes rows from a clustered index.", detail: "Physical operator that deletes rows from the specified clustered index. May cascade to nonclustered indexes.", types: ["Physical"], msDoc: "**Clustered Index Delete** deletes rows from a clustered index. Physical operator that deletes rows from the specified clustered index. May cascade to nonclustered indexes." },
  { name: "Clustered Index Merge", category: "Modify", icon: "icon-clustered-index-merge", summary: "Applies a mix of insert/update/delete operations to a clustered index.", detail: "Applies a merge data stream (inserts, updates, and deletes) to a clustered index. The ActionColumn determines which operation to perform for each row. Used in MERGE statements.", types: ["Physical"], msDoc: "**Clustered Index Merge** applies a mix of insert/update/delete operations to a clustered index. Applies a merge data stream (inserts, updates, and deletes) to a clustered index. The ActionColumn determines which operation to perform for each row. Used in MERGE statements." },
  { name: "Index Insert", category: "Modify", icon: "icon-nonclustered-index-insert", summary: "Inserts rows into a nonclustered index.", detail: "Physical operator that inserts rows into the specified nonclustered index.", types: ["Physical"], msDoc: "**Index Insert** inserts rows into a nonclustered index. Physical operator that inserts rows into the specified nonclustered index." },
  { name: "Index Update", category: "Modify", icon: "icon-nonclustered-index-update", summary: "Updates rows in a nonclustered index.", detail: "Physical operator that updates rows in the specified nonclustered index.", types: ["Physical"], msDoc: "**Index Update** updates rows in a nonclustered index. Physical operator that updates rows in the specified nonclustered index." },
  { name: "Index Delete", category: "Modify", icon: "icon-nonclustered-index-delete", summary: "Deletes rows from a nonclustered index.", detail: "Physical operator that deletes rows from the specified nonclustered index.", types: ["Physical"], msDoc: "**Index Delete** deletes rows from a nonclustered index. Physical operator that deletes rows from the specified nonclustered index." },
  { name: "Table Insert", category: "Modify", icon: "icon-table-insert", summary: "Inserts rows into a heap table.", detail: "Physical operator that inserts rows into a heap (table without a clustered index).", types: ["Physical"], msDoc: "**Table Insert** inserts rows into a heap table. Physical operator that inserts rows into a heap (table without a clustered index)." },
  { name: "Table Update", category: "Modify", icon: "icon-table-update", summary: "Updates rows in a heap table.", detail: "Physical operator that updates rows in a heap table.", types: ["Physical"], msDoc: "**Table Update** updates rows in a heap table. Physical operator that updates rows in a heap table." },
  { name: "Table Delete", category: "Modify", icon: "icon-table-delete", summary: "Deletes rows from a heap table.", detail: "Physical operator that deletes rows from a heap table.", types: ["Physical"], msDoc: "**Table Delete** deletes rows from a heap table. Physical operator that deletes rows from a heap table." },
  { name: "Columnstore Index Insert", category: "Modify", icon: "icon-columnstore-index-insert", summary: "Inserts rows into a columnstore index.", detail: "Physical operator for inserting rows into a clustered or nonclustered columnstore index.", types: ["Physical"], msDoc: "**Columnstore Index Insert** inserts rows into a columnstore index. Physical operator for inserting rows into a clustered or nonclustered columnstore index." },
  { name: "Columnstore Index Update", category: "Modify", icon: "icon-columnstore-index-update", summary: "Updates rows in a columnstore index.", detail: "Physical operator for updating rows in a columnstore index.", types: ["Physical"], msDoc: "**Columnstore Index Update** updates rows in a columnstore index. Physical operator for updating rows in a columnstore index." },
  { name: "Columnstore Index Delete", category: "Modify", icon: "icon-columnstore-index-delete", summary: "Deletes rows from a columnstore index.", detail: "Physical operator for deleting rows from a columnstore index.", types: ["Physical"], msDoc: "**Columnstore Index Delete** deletes rows from a columnstore index. Physical operator for deleting rows from a columnstore index." },
  { name: "Columnstore Index Merge", category: "Modify", icon: "icon-columnstore-index-merge", summary: "Applies a merge data stream to a columnstore index.", detail: "Applies insert/update/delete operations to a columnstore index based on the ActionColumn value.", types: ["Physical"], msDoc: "**Columnstore Index Merge** applies a merge data stream to a columnstore index. Applies insert/update/delete operations to a columnstore index based on the ActionColumn value." },
  { name: "Split", category: "Modify", icon: "icon-split", summary: "Splits an update into separate delete + insert operations.", detail: "Used with Collapse to optimize update processing. Splits each update row into a delete of the old values and an insert of the new values. This allows the optimizer to process the operations more efficiently, especially when key columns change.", types: ["Logical", "Physical"], msDoc: "**Split** splits an update into separate delete + insert operations. Used with Collapse to optimize update processing. Splits each update row into a delete of the old values and an insert of the new values. This allows the optimizer to process the operations more efficiently, especially when key columns change." },
  { name: "Collapse", category: "Modify", icon: "icon-collapse", summary: "Combines adjacent delete+insert of the same key back into an update.", detail: "Works with Split to optimize updates. If adjacent rows in the stream delete and insert the same key values, Collapse merges them back into a single, more efficient update operation.", types: ["Logical", "Physical"], msDoc: "**Collapse** combines adjacent delete+insert of the same key back into an update. Works with Split to optimize updates. If adjacent rows in the stream delete and insert the same key values, Collapse merges them back into a single, more efficient update operation." },
  { name: "Remote Insert", category: "Modify", icon: "icon-remote-insert", summary: "Inserts rows into a remote (linked server) table.", detail: "Physical operator that inserts input rows into a table on a remote linked server.", types: ["Logical", "Physical"], msDoc: "**Remote Insert** inserts rows into a remote (linked server) table. Physical operator that inserts input rows into a table on a remote linked server." },
  { name: "Remote Update", category: "Modify", icon: "icon-remote-update", summary: "Updates rows on a remote (linked server) table.", detail: "Physical operator that updates rows in a table on a remote linked server.", types: ["Logical", "Physical"], msDoc: "**Remote Update** updates rows on a remote (linked server) table. Physical operator that updates rows in a table on a remote linked server." },
  { name: "Remote Delete", category: "Modify", icon: "icon-remote-delete", summary: "Deletes rows from a remote (linked server) table.", detail: "Physical operator that deletes rows from a table on a remote linked server.", types: ["Logical", "Physical"], msDoc: "**Remote Delete** deletes rows from a remote (linked server) table. Physical operator that deletes rows from a table on a remote linked server." },
  { name: "Online Index Insert", category: "Modify", icon: "icon-nonclustered-index-insert", summary: "Indicates an online index operation (CREATE/ALTER/DROP INDEX).", detail: "Indicates that an index create, alter, or drop is being performed online — table data remains accessible during the operation.", types: ["Physical"], msDoc: "**Online Index Insert** indicates an online index operation (CREATE/ALTER/DROP INDEX). Indicates that an index create, alter, or drop is being performed online — table data remains accessible during the operation." },

  // === SPOOLS ===
  { name: "Table Spool", category: "Spools", icon: "icon-table-spool", summary: "Stores intermediate rows in a hidden tempdb table for reuse.", detail: "Caches input rows in a hidden worktable in tempdb. Used to avoid rescanning expensive subtrees, especially inside Nested Loops. Can be Eager (reads all rows upfront) or Lazy (reads rows on demand).", types: ["Physical"], msDoc: "The **Spool** operator saves an intermediate query result to the tempdb database." },
  { name: "Index Spool", category: "Spools", icon: "icon-nonclustered-index-spool", summary: "Builds a temporary nonclustered index on spooled rows.", detail: "Caches rows in tempdb and builds a nonclustered index on them. Enables index seeks on the cached data, which is useful inside Nested Loops when the inner side would otherwise need repeated scans.", types: ["Physical"], msDoc: "The **Index Spool** operator contains a *seek* predicate in the **Properties** pane. The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the tempdb database and existing only for the lifetime of the query), and builds a nonclustered index on the rows. This allows you to use the seeking capability of indexes to output only those rows that satisfy the *seek* predicate. If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.\n\n**Index Spool** is a physical operator." },
  { name: "Row Count Spool", category: "Spools", icon: "icon-spool", summary: "Counts rows without storing data — used for EXISTS checks.", detail: "Scans input and counts rows but doesn't store the actual data. Used to optimize semi-join operations where only the existence of rows matters, not the row data itself.", types: ["Physical"], msDoc: "The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them. This operator is used when it's important to check for the existence of rows, rather than the data contained in the rows.\n\n**Row Count Spool** is a physical operator." },
  { name: "Eager Spool", category: "Spools", icon: "icon-spool", summary: "Reads ALL input rows upfront into tempdb before returning any.", detail: "Consumes the entire input and stores all rows in a hidden tempdb worktable before the parent operator gets any rows. Blocking operator. Used when the full set must be materialized, e.g., for Halloween Protection in UPDATE/DELETE operations.", types: ["Logical"], msDoc: "The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the tempdb database. If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input. If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input. The **Eager Spool** operator builds its spool file in an \"eager\" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.\n\n**Eager Spool** is a logical operator." },
  { name: "Lazy Spool", category: "Spools", icon: "icon-spool", summary: "Caches rows one at a time as they're requested.", detail: "Stores each row in tempdb as the parent requests it, rather than consuming all input upfront. Non-blocking. On rewind, returns cached rows instead of rescanning the input.", types: ["Logical"], msDoc: "The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the tempdb database. If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input. If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input. The **Lazy Spool** operator builds its spool file in a \"lazy\" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.\n\n**Lazy Spool** is a logical operator." },

  // === PARALLELISM ===
  { name: "Parallelism (Gather Streams)", category: "Parallelism", icon: "icon-parallelism", summary: "Combines multiple parallel streams into one.", detail: "Collects rows from multiple parallel threads into a single output stream. If order-preserving, maintains sorted order across all input streams. Appears at the end of a parallel region.", types: ["Physical"], msDoc: "**Parallelism (Gather Streams)** combines multiple parallel streams into one. Collects rows from multiple parallel threads into a single output stream. If order-preserving, maintains sorted order across all input streams. Appears at the end of a parallel region." },
  { name: "Parallelism (Distribute Streams)", category: "Parallelism", icon: "icon-parallelism-distribute-streams", summary: "Splits one stream into multiple parallel streams.", detail: "Takes a single input stream and distributes records across multiple output streams for parallel processing. Uses hashing to determine which thread gets each row. Appears at the start of a parallel region.", types: ["Physical"], msDoc: "**Parallelism (Distribute Streams)** splits one stream into multiple parallel streams. Takes a single input stream and distributes records across multiple output streams for parallel processing. Uses hashing to determine which thread gets each row. Appears at the start of a parallel region." },
  { name: "Parallelism (Repartition Streams)", category: "Parallelism", icon: "icon-parallelism", summary: "Redistributes rows across parallel threads using a different partitioning scheme.", detail: "Re-hashes rows from multiple input streams to multiple output streams using a different partition function. Used when a parallel plan needs data redistributed by different columns mid-execution.", types: ["Physical"], msDoc: "**Parallelism (Repartition Streams)** redistributes rows across parallel threads using a different partitioning scheme. Re-hashes rows from multiple input streams to multiple output streams using a different partition function. Used when a parallel plan needs data redistributed by different columns mid-execution." },
  { name: "Bitmap", category: "Parallelism", icon: "icon-bitmap", summary: "Bitmap filter to eliminate non-matching rows early in parallel plans.", detail: "Creates a compact bitmap representation of key values from one table. Used in parallel joins to filter out rows from the probe side that can't possibly match, reducing data movement between threads.", types: ["Physical"], msDoc: "SQL Server uses the **Bitmap** operator to implement bitmap filtering in parallel query plans. Bitmap filtering speeds up query execution by eliminating rows with key values that can't produce any join records before passing rows through another operator such as the **Parallelism** operator. A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree. By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves. The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.\n\n**Bitmap** is a physical operator." },
  { name: "Broadcast", category: "Parallelism", icon: "icon-broadcast", summary: "Sends all rows to every parallel consumer.", detail: "Sends every input row to all consumer threads. Used when every parallel thread needs the complete data set, such as building hash tables on all threads.", types: ["Physical"], msDoc: "**Broadcast** sends all rows to every parallel consumer. Sends every input row to all consumer threads. Used when every parallel thread needs the complete data set, such as building hash tables on all threads." },

  // === CURSORS ===
  { name: "Fetch Query", category: "Cursors", icon: "icon-fetch-query", summary: "Retrieves rows when a FETCH is issued against a cursor.", detail: "Physical operator that retrieves rows in response to a FETCH statement on a cursor.", types: ["Physical"], msDoc: "**Fetch Query** retrieves rows when a FETCH is issued against a cursor. Physical operator that retrieves rows in response to a FETCH statement on a cursor." },
  { name: "Population Query", category: "Cursors", icon: "icon-population-query", summary: "Populates a cursor's work table when the cursor is opened.", detail: "Fills the work table that backs a cursor when OPEN CURSOR is executed.", types: ["Physical"], msDoc: "**Population Query** populates a cursor's work table when the cursor is opened. Fills the work table that backs a cursor when OPEN CURSOR is executed." },
  { name: "Refresh Query", category: "Cursors", icon: "icon-refresh-query", summary: "Fetches current data for rows in the cursor's fetch buffer.", detail: "Retrieves up-to-date data for rows currently in the fetch buffer of a keyset or dynamic cursor.", types: ["Physical"], msDoc: "**Refresh Query** fetches current data for rows in the cursor's fetch buffer. Retrieves up-to-date data for rows currently in the fetch buffer of a keyset or dynamic cursor." },
  { name: "Dynamic (Cursor)", category: "Cursors", icon: "icon-dynamic", summary: "Dynamic cursor — sees all changes made by others.", detail: "Physical cursor implementation that can see inserts, updates, and deletes made by other transactions in real time.", types: ["Physical"], msDoc: "**Dynamic (Cursor)** — dynamic cursor sees all changes made by others. Physical cursor implementation that can see inserts, updates, and deletes made by other transactions in real time." },
  { name: "Keyset (Cursor)", category: "Cursors", icon: "icon-keyset", summary: "Keyset cursor — sees updates but not inserts by others.", detail: "Physical cursor implementation where the set of qualifying rows (keyset) is fixed at open time. Can see updates to those rows but not new inserts by other transactions.", types: ["Physical"], msDoc: "**Keyset (Cursor)** — keyset cursor sees updates but not inserts by others. Physical cursor implementation where the set of qualifying rows (keyset) is fixed at open time. Can see updates to those rows but not new inserts by other transactions." },
  { name: "Snapshot (Cursor)", category: "Cursors", icon: "icon-snapshot", summary: "Snapshot cursor — static view, doesn't see changes.", detail: "Physical cursor implementation that takes a snapshot of the data at open time. Does not see any subsequent changes.", types: ["Physical"], msDoc: "**Snapshot (Cursor)** — snapshot cursor static view, doesn't see changes. Physical cursor implementation that takes a snapshot of the data at open time. Does not see any subsequent changes." },

  // === OTHER ===
  { name: "Compute Scalar", category: "Other", icon: "icon-compute-scalar", summary: "Evaluates an expression to produce a calculated value.", detail: "Evaluates a scalar expression (math, string manipulation, type conversion, CASE, etc.) and adds the result as a new column. Very common and usually low-cost. Sometimes the runtime folds Compute Scalar work into other operators.", types: ["Logical", "Physical"], msDoc: "The **Compute Scalar** operator evaluates an expression to produce a computed scalar value. This might then be returned to the user, referenced elsewhere in the query, or both. An example of both is in a filter predicate or join predicate.\n\n**Compute Scalar** operators that appear in showplans generated by SET STATISTICS XML might not contain the **RunTimeInformation** element. In graphical showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in SQL Server Management Studio. When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the runtime query plan.\n\n**Compute Scalar** is a logical and physical operator." },
  { name: "Filter", category: "Other", icon: "icon-filter", summary: "Filters rows based on a predicate (WHERE-like).", detail: "Scans input and returns only rows satisfying the filter expression. Unlike predicates pushed into Seek/Scan operators, Filter is a separate step applied after data retrieval.", types: ["Logical", "Physical"], msDoc: "The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the **Properties** pane." },
  { name: "Concatenation", category: "Other", icon: "icon-concatenation", summary: "Combines multiple inputs into one stream (UNION ALL).", detail: "Reads from multiple input streams sequentially, outputting all rows from each. Commonly implements UNION ALL. Does not remove duplicates — for UNION (distinct), a Sort or Hash Match follows.", types: ["Logical", "Physical"], msDoc: "The **Concatenation** operator scans multiple inputs, returning each row scanned. **Concatenation** is typically used to implement the Transact-SQL UNION ALL construct. The **Concatenation** physical operator has two or more inputs and one output. Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.\n\n**Concatenation** is a logical and physical operator." },
  { name: "Assert", category: "Other", icon: "icon-assert", summary: "Verifies a condition (e.g., referential integrity, subquery returns one row).", detail: "Evaluates an expression for each input row. If the expression is NULL, the row passes through. If non-null, an error is raised. Used for constraint validation, scalar subquery cardinality checks, etc.", types: ["Physical"], msDoc: "The **Assert** operator verifies a condition. For example, it validates referential integrity or ensures that a scalar subquery returns one row. For each input row, the **Assert** operator evaluates the expression in the **Properties** pane of the execution plan. If this expression evaluates to NULL, the row is passed through the **Assert** operator and the query execution continues. If this expression evaluates to a non-null value, the appropriate error is raised.\n\n**Assert** is a physical operator." },
  { name: "Foreign Key References Check", category: "Other", icon: "icon-referential-integrity", summary: "Checks referential integrity against foreign key constraints.", detail: "Compares modified rows against referencing tables to verify foreign key integrity. Used when more than 253 foreign key references exist on the same key.", types: ["Logical", "Physical"], msDoc: "**Foreign Key References Check** checks referential integrity against foreign key constraints. Compares modified rows against referencing tables to verify foreign key integrity. Used when more than 253 foreign key references exist on the same key." },
  { name: "Merge Interval", category: "Other", icon: "icon-merge-interval", summary: "Merges overlapping intervals into minimal non-overlapping ranges.", detail: "Takes potentially overlapping intervals and produces minimal, non-overlapping intervals. These are then used to seek index entries efficiently. Common in queries with OR conditions or BETWEEN on the same column.", types: ["Logical", "Physical"], msDoc: "**Merge Interval** merges overlapping intervals into minimal non-overlapping ranges. Takes potentially overlapping intervals and produces minimal, non-overlapping intervals. These are then used to seek index entries efficiently. Common in queries with OR conditions or BETWEEN on the same column." },
  { name: "Arithmetic Expression", category: "Other", icon: "icon-arithmetic-expression", summary: "Computes a new value from existing row values (legacy).", detail: "Legacy operator that computes new values from existing row values. Not used in newer versions of SQL Server — replaced by Compute Scalar.", types: ["Logical", "Physical"], msDoc: "**Arithmetic Expression** computes a new value from existing row values (legacy). Legacy operator that computes new values from existing row values. Not used in newer versions of SQL Server — replaced by Compute Scalar." },
  { name: "Switch", category: "Other", icon: "icon-switch", summary: "Routes rows to different outputs based on a condition.", detail: "Evaluates an expression and routes each row to one of multiple output streams based on the result. Used in partitioned view updates and other conditional routing scenarios.", types: ["Physical"], msDoc: "**Switch** routes rows to different outputs based on a condition. Evaluates an expression and routes each row to one of multiple output streams based on the result. Used in partitioned view updates and other conditional routing scenarios." },
  { name: "Sequence", category: "Other", icon: "icon-sequence", summary: "Executes child operations in order, returns last result.", detail: "Activates each child plan in order (first to last) and returns the result of the last child. Used when multiple operations must execute in sequence, like multi-table updates.", types: ["Physical"], msDoc: "**Sequence** executes child operations in order, returns last result. Activates each child plan in order (first to last) and returns the result of the last child. Used when multiple operations must execute in sequence, like multi-table updates." },
  { name: "Result", category: "Other", icon: "icon-result", summary: "Returns the final result of the query.", detail: "The Result operator is the data returned at the end of a query plan. This is typically the root of the showplan tree.", types: ["Physical"], msDoc: "**Result** returns the final result of the query. The Result operator is the data returned at the end of a query plan. This is typically the root of the showplan tree." },
  { name: "Assign", category: "Other", icon: "icon-assign", summary: "Assigns a value to a variable.", detail: "Assigns the value of an expression or constant to a local variable. Language element in the execution plan.", types: ["Language"], msDoc: "**Assign** assigns a value to a variable. Assigns the value of an expression or constant to a local variable. Language element in the execution plan." },
  { name: "Declare", category: "Other", icon: "icon-declare", summary: "Declares a local variable.", detail: "Allocates a local variable in the query plan. Language element.", types: ["Language"], msDoc: "**Declare** declares a local variable. Allocates a local variable in the query plan. Language element." },
  { name: "If / While (Conditional)", category: "Other", icon: "icon-conditional", summary: "Conditional processing (IF/WHILE loops).", detail: "Carries out conditional processing based on IF conditions or WHILE loops in the T-SQL batch.", types: ["Language"], msDoc: "**If / While (Conditional)** conditional processing (IF/WHILE loops). Carries out conditional processing based on IF conditions or WHILE loops in the T-SQL batch." },
  { name: "Convert", category: "Other", icon: "icon-convert", summary: "Converts one data type to another.", detail: "Explicit data type conversion. Language element in the execution plan.", types: ["Language"], msDoc: "**Convert** converts one data type to another. Explicit data type conversion. Language element in the execution plan." },
  { name: "Intrinsic", category: "Other", icon: "icon-intrinsic", summary: "Invokes an internal T-SQL function.", detail: "Calls an internal SQL Server function. Language element.", types: ["Language"], msDoc: "**Intrinsic** invokes an internal T-SQL function. Calls an internal SQL Server function. Language element." },
  { name: "Table-valued Function", category: "Other", icon: "icon-table-valued-function", summary: "Calls a table-valued function and returns its result set.", detail: "Evaluates a table-valued function (TVF) and returns the rows it produces. Can be either an inline TVF (expanded into the plan) or a multi-statement TVF (executed as a black box).", perf: "Multi-statement TVFs are optimized poorly — the optimizer estimates 1 row regardless of actual output. Consider inline TVFs instead.", types: ["Logical", "Physical"], msDoc: "**Table-valued Function** calls a table-valued function and returns its result set. Evaluates a table-valued function (TVF) and returns the rows it produces. Can be either an inline TVF (expanded into the plan) or a multi-statement TVF (executed as a black box)." },
  { name: "UDX (User Defined Extension)", category: "Other", icon: "icon-udx", summary: "Represents extended operations like XQuery or FOR XML.", detail: "Implements extended relational operations such as XQuery expressions, XML plan operations, or other user-defined extensions.", types: ["Logical", "Physical"], msDoc: "**UDX (User Defined Extension)** represents extended operations like XQuery or FOR XML. Implements extended relational operations such as XQuery expressions, XML plan operations, or other user-defined extensions." },
  { name: "Batch Hash Table Build", category: "Other", icon: "icon-batch-hash-table-build", summary: "Builds a hash table for batch mode columnstore operations.", detail: "Builds a batch-mode hash table for memory-optimized columnstore index operations. SQL Server 2012 only.", types: ["Physical"], msDoc: "**Batch Hash Table Build** builds a hash table for batch mode columnstore operations. Builds a batch-mode hash table for memory-optimized columnstore index operations. SQL Server 2012 only." },
  { name: "Async Concat", category: "Other", icon: "icon-iterator-catch-all", summary: "Simultaneously opens multiple remote inputs in distributed queries.", detail: "Used in distributed queries. Issues Open() to all child nodes simultaneously (often remote servers), then collects output rows on demand using a bitmap to track which children have data.", types: ["Physical"], msDoc: "**Async Concat** simultaneously opens multiple remote inputs in distributed queries. Used in distributed queries. Issues Open() to all child nodes simultaneously (often remote servers), then collects output rows on demand using a bitmap to track which children have data." },
  { name: "Cursor (Catch-all)", category: "Other", icon: "icon-cursor-catch-all", summary: "Generic cursor operator for cursor-based query execution.", detail: "Catch-all operator for cursor operations. Logical cursor operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary, and Synchronous.", types: ["Logical", "Physical"], msDoc: "**Cursor (Catch-all)** generic cursor operator for cursor-based query execution. Catch-all operator for cursor operations. Logical cursor operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary, and Synchronous." },
  { name: "Iterator (Catch-all)", category: "Other", icon: "icon-iterator-catch-all", summary: "Generic iterator — displayed when no specific icon exists.", detail: "Catch-all icon displayed when the showplan logic can't find a specific icon for an iterator. Does not indicate an error.", types: ["Physical"], msDoc: "**Iterator (Catch-all)** generic iterator — displayed when no specific icon exists. Catch-all icon displayed when the showplan logic can't find a specific icon for an iterator. Does not indicate an error." },
  { name: "Language Element (Catch-all)", category: "Other", icon: "icon-language-construct-catch-all", summary: "Generic language element — displayed when no specific icon exists.", detail: "Catch-all icon for language constructs that don't have a dedicated icon.", types: ["Language"], msDoc: "**Language Element (Catch-all)** generic language element — displayed when no specific icon exists. Catch-all icon for language constructs that don't have a dedicated icon." },
];

// Operator lookup by name
const operatorMap = Object.fromEntries(operators.map(op => [op.name, op]));
